

# Dremma开发者文档

## 基本概念

### 游戏引擎是什么？

游戏引擎是帮助游戏创作者创作游戏的软件

### 游戏引擎存在的目的：

游戏引擎保障基础设施，激发游戏创作的无限可能

### 游戏开发者为什么要使用游戏引擎呢？

为了在保证质量的前提下高效完成游戏开发需求

### 小型游戏引擎的价值在哪里？

站在游戏开发者的角度，我既可以从零开始开发，又可以基于引擎，而学习庞大复杂的引擎需要很高的学习成本，但自己从零开发又会拖慢开发进度，有没有五脏俱全、容易上手的小引擎呢？

作为一个仅有129KB的Jar包，游戏开发者如何利用它达成自己的2D游戏开发目标呢？

## 2D游戏开发需求洞察

### 核心配置

是否开启Debug日志：查看游戏帧数，游戏开发过程中输出的信息、警告及错误

游戏目标平台：Applet还是Java Application

窗体大小

游戏名称：决定日志中显示的名称的及游戏窗体标题

### 核心工具

#### 调试支持

Debug.log输出日志 配图

#### 事件处理

键盘事件，按键绑定（多个键盘可以绑定一个虚拟键，如w键及上箭头键绑定名为up的虚拟键，虚拟键名称可自定义），鼠标事件，窗体事件 配图

#### 时间运转

可通过时间类配置是否开启帧数锁定，帧数锁定到多少，获取每帧经过的时长，已经过去的时长，当前时间等等

#### Vector2

二维向量的封装，提供插值、运算、比较、模长、归一化等方法



### 资源加载

巧妇难为无米之炊

资源包括贴图、音频、动画、地图配置文件、对话内容等

开发者可调用Resource类提供的API方法便捷地加载及获取各类资源文件

### 地图设计

地图是游戏的世界，游戏中的一草一木、飞禽走兽以及玩家的化身都在地图之中

开发者可以通过资源加载提供的方法绑定地砖编号与对应贴图，然后通过由地砖编号构成的配置文件即可由引擎生成游戏地图。

### 游戏世界的生机

草木飞禽、npc以及玩家，这些都是地图的重要组成部分，有了它们游戏世界才能焕发生机。

在梦玛引擎中，Entity是所有实体的父类，它提供可视性、是否静态等配置，开发者可以通过Animator为非静态Entity添加动画状态机，设置动画状态的转换有无退出时间，静态实体只需设置贴图即可，梦玛引擎通过继承多态扩展功能，开发者只需继承Entity，重写其生命周期函数即可，Entity主要提供构造函数、onStart，onUpdate及OnDestroy，分别在实体构造时，进入游戏地图中时，更新时及被销毁时调用。

### 碰撞处理

开发者终于做出了一个丰富的游戏世界，但各个物体间都可以通过，而开发者如果不想让某些物体间直接穿过，要怎么办呢？这就需要用到碰撞系统的检测与处理了，梦玛引擎提供了可视化可调整的碰撞盒，开发者将碰撞盒添加到实体身上，指定自己希望的碰撞盒模式：触发器与非触发器，在发生碰撞时，引擎会做相应的处理，保证非触发器模式不穿模，此外，梦玛引擎提供了onCollision、onTriggerEnter及onTriggerExit等钩子函数给开发者做自己的碰撞处理，分别代表发生非触发器碰撞、进入触发器碰撞盒、退出触发器碰撞盒

### 移动帮助

很多小型游戏引擎需要开发者在代码中指定实体摆放位置，但实际上在代码中修改后需要重新运行才能看到效果，对于物体位置调整来说非常不便，梦玛引擎提供可视化的实体移动帮助工具，开发者无需在代码中调整，只需在引擎运行时拖动移动工具 配图 调整位置即可，引擎会在关闭时序列化存入移动帮助及碰撞盒调整数据，在下次启动时载入

### 动画系统

不管是人物的行走，还是怪物的死亡，都需要有动画的播放及动画状态的转换，对于从零开始开发游戏的开发者而言，每个角色都需要写一套有限动画状态机，非常麻烦而且混乱。梦玛引擎提供关键帧动画Animation类及动画状态机Animator类，Animation可以通过添加图片及其对应播放时间自动维护关键帧动画的播放，Animator管理动画状态，可向其中增删动画状态，进行状态转换，配置转换过程有无退出时间

### 音频播放

音频播放支持可以直接通过加载音乐文件的名字调用播放一次、播放多次、循环播放、设置音量等函数，支持wav、au格式

### UI

UI是玩家与游戏用户界面交互的载体，比如血条、背包图标、背包等，梦玛引擎提供UIEntity及UIManager类处理UI系统的任务，UIEntity是Entity的孩子，可以使用移动帮助，并且自身提供UI对齐、模式等配置；UIManager可以进行UI绑定、解绑、可视性设置、添加、删除等操作。Text继承自UIEntity，用于针对文字的处理，可配置文字的大小、颜色、字体及行宽等

## 如何使用我的游戏引擎呢？

钩子函数

​	生命周期函数

​	碰撞检测回调函数

引擎内置工具类

​	时间

​	Vector2

​	Debug

​	坐标转换

​	浮点数比较

​	资源加载

​		音乐

​		地砖

实体

​	Entity介绍

​		对Entity进行变换

​		生命周期

​		可视性

​	UIEntity介绍

​		UI模式（世界、屏幕）

​		UI对齐

​		UI层级

​		UI事件监听

​	AttackEntity介绍

​		攻击型实体的特殊性

事件处理

​	按键绑定

​	键盘事件处理

​	鼠标事件处理

​	窗体事件处理

## 我的游戏引擎和别的游戏引擎比较有什么优势呢？

与大型游戏引擎比起来非常小巧、轻量（Jar包139KB）

可以打包为可执行Jar包和Applet小程序，利用Java的跨平台特性

默认解决人树渲染顺序问题，不需要复杂的配置

与其他小型纯游戏引擎相比，很多小型游戏引擎不提供场景编辑功能，DremmaEngine提供可视化的碰撞盒调整以及可视化的位置调整，调整逻辑与unity相似，容易上手

可以处理两个运动物体间的碰撞

由于小巧，学习成本低，也方便对游戏引擎功能实现感兴趣的人分析源码学习